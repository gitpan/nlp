m4_divert(-1)
# ---------------------------------------
# 			styles.c.in
# ---------------------------------------
# This file is to be processed by GNU m4 with --prefix-builtins
#
# This file describes different languages : their words alphabet,
# their keywords, their symbols, their special symbols,
# their sequences type (eg. strings, comments), their exceptions
# in the sequences, ...
# You can add new features to this program simply by modifying
# this file and adding you new style in 'struct_for_highlight'
# 
# To define a new list of keywords, use the macro 
# 		`a2_keywords(font, kw1, kw2, ...)'
# where the first argument is the font to be used (courier, bold,
# italic, invisible, symbol, times, emph (=bold-italic),
# and the following arguments are the keywords
# 
# To define a new sequence, use the macro 
# 		`ac_sequence(ms, fs, fi, me, fe)'
# where ms is the beginning marker, fs its font, fi is the font
# to be used inside the the sequence, me and fe the ending marker
# and its font
# 
m4_changecom 

# m4_foreach(x, (item_1, item_2, ..., item_n), stmt)
m4_define(`m4_foreach', 
          `m4_pushdef(`$1', `')_foreach(`$1', `$2', `$3')m4_popdef(`$1')')
m4_define(`_arg1', `$1')
m4_define(`_foreach', 
        `m4_ifelse(`$2', `()', ,
                `m4_define(`$1', _arg1$2)$3`'_foreach(`$1', (m4_shift$2), `$3')')')

# to UPCASE
m4_define(`m4_upcase', 
	  `m4_translit(`$*', `a-z', `A-Z')')

# expand a comma-separated list of keywords
m4_define(`a2_font', `FONT_`'m4_upcase($1)')
m4_define(`a2_keyword',
          `a2_keyword1(m4_upcase($1), m4_shift($@))')
m4_define(`a2_keyword1',
          `m4_ifelse($#, 2, `(ustring)"$2", a2_font($1),
', `(ustring)"$2", a2_font($1),
  a2_keyword1($1, m4_shift(m4_shift($@)))')')

# Define the symbols
m4_define(`a2_symbol', `(ustring) "$1", (ustring) "$2", FONT_SYMBOL')
m4_define(`a2_invisible1', `(ustring) "$1", UNULL, FONT_INVISIBLE')
m4_define(`a2_invisible', 
          `m4_foreach(`a2_var', `($@)', `a2_invisible1(a2_var),')')

# Make it easy to define some symbols (regular or special)
m4_define(`a2_define_symbol', 
	  `m4_define(`a2_$1', `(ustring)"$'1`", (ustring)"$2", FONT_SYMBOL')')

# This is a list of the most useful symbols. 
# Latex syntax is used.
a2_define_symbol(leq,		\243)
a2_define_symbol(rightarrow,	\256)
a2_define_symbol(geq,		\263)
a2_define_symbol(neq,		\271)
a2_define_symbol(equiv,		\272)
a2_define_symbol(oplus,		\305)
a2_define_symbol(not, 		\330)
a2_define_symbol(and, 		\331)
a2_define_symbol(wedge, 	\331)
a2_define_symbol(or, 		\332)
a2_define_symbol(vee, 		\332)
a2_define_symbol(Leftarrow, 	\335)
a2_define_symbol(imply, 	\336)
a2_define_symbol(Rightarrow, 	\336)

# Define a list of style descriptions
m4_define(`a2_styles',
	  `struct struct_for_highlight languages [] =
{
  $1_style`'m4_foreach(`a2_var', `(m4_shift($@))', `,
  a2_var`'_style')
};')

#_dnl expand a single sequence definition line
m4_define(`a2_sequence', 
          `(ustring)"$1", a2_font($2), a2_font($3), (ustring)"$4", a2_font($5)')

m4_divert`'m4_dnl
/***************************************************************
 *			styles.c
 *
 * Please do not edit this file by hand: it has been
 * generated from styles.c.in through (GNU) m4 with option
 * --prefix-builtins
 * This file describes different languages : their words alphabet,
 * their keywords, their symbols, their special symbols,
 * their sequences type (eg. strings, comments), their exceptions
 * in the sequences, ...
 *
 * You can add new features to this program simply by modifying
 * this file.
 * All you have to do is to add a new item to the global
 * variable languages.
 *
 ****************************************************************/

/************************************************************************/
/*									*/
/* Description: Ascii to PostScript printer program.			*/
/* File: http://www.enst.fr/~demaille/a2ps.html				*/
/* Created: Oct, 20 1996, by  demaille@inf.enst.fr (Demaille Akim)	*/
/* Version: 4.6								*/
/*									*/
/* Edit history:							*/
/* Modified by Emmanuel Briot (Emmanuel.Briot@enst-bretagne.fr)         */
/*  1) Built the keyword highlight mode					*/
/*  2) Added C/C++, Perl, Ada and Caml modes				*/
/* Modified by Akim Demaille (demaille@inf.enst.fr)                     */
/*  3) Added eiffel, sh, claire, lace key word Highligting              */
/*  4) Adding description of the alphabet for the keywords		*/
/*  5) Added the symbol translation (-t, -nt)				*/
/*  6) Case sensitiveness according to the language			*/
/*  7) Added sdl, and distinguished c from c++				*/
/*  8) Added specials, double-set alphabet description, and zsh style	*/
/*  9) Added promela, mail and java style				*/
/* 10) Sequences now have three fonts (open, in, close)			*/
/* 11) Changed handling of lexical exceptions: verbatims and escapes	*/
/* 12) Added tcl, tk and o2c style					*/
/* 13) Keywords are now defined with their font type			*/
/* 14) Added Sather, python, postscript, html, modula3 styles		*/
/* 15) Added the invisible font, possibilities with sequences augmented	*/
/* 16) Description for languages, and automatic recognition		*/
/* 17) Added Pascal, used m4						*/
/* Modified by Denis Girou (Denis.Girou@idris.fr)			*/
/* 18) Added Fortran 90							*/
/*									*/
/************************************************************************/
#include "config.h"
#include "a2ps.h"
#include "styles.h"

const unsigned char * EMPTY [] = {
  UNULL
};

/*
 * Map of the file
 *
 * 1. Prescript
 * 2. Misceleanous
 *   mail, postscript, html
 * 3. Shell-scripts
 *   sh, zsh, perl
 * 4. Eiffel family
 *   eiffel, lace
 * 5. C family
 *   c, cpp, o2c
 * 6. TCL family
 *   tcl, tk
 * 7. Object-oriented languages
 *   claire, java, ada, sather, python
 * 8. Functional languages
 *   caml, clisp, scheme, coq
 * 9. Modula family
 *   pascal, modula3, oberon
 * 10. Specification languages
 *   promela, sdl
 * 11. Fortran
 * 12. Assembly languages
 *    M68000
 */


/************************************************************************/
/*									*/
/* 		Definition of the various styles			*/
/*									*/
/************************************************************************/
/*
 *		prescript
 */
const unsigned char* prescript_sequences [] = { 
  /* Skip portions not destined to a2ps, but only to LaTeX */
  a2_sequence(%%prescript:skip\n, INVISIBLE,
  INVISIBLE,
  %%prescript:piks\n, INVISIBLE),
  a2_sequence(%, INVISIBLE, INVISIBLE, \n, INVISIBLE), 

  /* lists */
  a2_sequence(\\item[, 		INVISIBLE, BOLD, ], INVISIBLE),
  /* titles */
  a2_sequence(\\section{, 		INVISIBLE, BOLD, }, INVISIBLE),
  a2_sequence(\\subsection{, 	INVISIBLE, BOLD, }, INVISIBLE),
  a2_sequence(\\subsubsection{, 	INVISIBLE, BOLD, }, INVISIBLE),
  /* change of font */
  a2_sequence(\\textbf{, INVISIBLE, BOLD,   }, INVISIBLE),
  a2_sequence(\\textit{, INVISIBLE, ITALIC, }, INVISIBLE),
  a2_sequence(\\textbi{, INVISIBLE, EMPH,   }, INVISIBLE),
  a2_sequence(\\textrm{, INVISIBLE, TIMES,  }, INVISIBLE),
  a2_sequence(\\textsy{, INVISIBLE, SYMBOL, }, INVISIBLE),
  a2_sequence(\\texttt{, INVISIBLE, COURIER,}, INVISIBLE),
  /* change of font but invisible in LaTeX */
  a2_sequence(\\magicbf{, INVISIBLE, BOLD,   }, INVISIBLE),
  a2_sequence(\\magicit{, INVISIBLE, ITALIC, }, INVISIBLE),
  a2_sequence(\\magicbi{, INVISIBLE, EMPH,   }, INVISIBLE),
  a2_sequence(\\magicrm{, INVISIBLE, TIMES,  }, INVISIBLE),
  a2_sequence(\\magicsy{, INVISIBLE, SYMBOL, }, INVISIBLE),
  a2_sequence(\\magictt{, INVISIBLE, COURIER,}, INVISIBLE),
  /* Verbatims */
  a2_sequence(\\verb+, INVISIBLE, COURIER, +, INVISIBLE),
  a2_sequence(\\verb!, INVISIBLE, COURIER, !, INVISIBLE),
  a2_sequence(\\verb|, INVISIBLE, COURIER, |, INVISIBLE),
  a2_sequence(\\verb#, INVISIBLE, COURIER, #, INVISIBLE),
  a2_sequence(\\verb=, INVISIBLE, COURIER, =, INVISIBLE),
  UNULL
};
const unsigned char prescript_chars_1 [] = {
  '\\', '\\',
  '_', '_',
  '\0'
};
const unsigned char prescript_chars_2 [] = {
  '_', '_',
  '\0'
};
const unsigned char* prescript_symbols [] = {
  /* Characters from LaTeX */
  a2_symbol(\\to, \256),
  a2_symbol(\\item, \267),
  (ustring)"\\backslash", (ustring) "\\",	FONT_COURIER,
  /* Things that must disapear */
  a2_invisible(\\begin{document}\n, \\end{document}\n,
   \\begin{itemize}\n, \\end{itemize}\n,
   \\begin{enumerate}\n, \\end{enumerate}\n,
   \\begin{description}\n, \\end{description}\n)

  /*
   * This is taken from the correspondance between font symbol
   * and LaTeX commands
   */
  /* 34: universal */   	a2_symbol(\\forall, \42),
  /* 36: existential */ 	a2_symbol(\\exists, \44),
  /* 39: suchthat */    	a2_symbol(\\suchthat, \47),
  /* 64: congruent */   	a2_symbol(\\cong, \100),
  /* 65: Alpha */       	a2_symbol(\\Alpha, \101),
  /* 66: Beta */        	a2_symbol(\\Beta, \102),
  /* 67: Chi */ 		a2_symbol(\\Chi, \103),
  /* 68: Delta */       	a2_symbol(\\Delta, \104),
  /* 69: Epsilon */     	a2_symbol(\\Epsilon, \105),
  /* 70: Phi */ 		a2_symbol(\\Phi, \106),
  /* 71: Gamma */       	a2_symbol(\\Gamma, \107),
  /* 72: Eta */ 		a2_symbol(\\Eta, \110),
  /* 73: Iota */        	a2_symbol(\\Iota, \111),
  /* 74: theta1 */      	a2_symbol(\\vartheta, \112),
  /* 75: Kappa */       	a2_symbol(\\Kappa, \113),
  /* 76: Lambda */      	a2_symbol(\\Lambda, \114),
  /* 77: Mu */  		a2_symbol(\\Mu, \115),
  /* 78: Nu */  		a2_symbol(\\Nu, \116),
  /* 79: Omicron */     	a2_symbol(\\Omicron, \117),
  /* 80: Pi */  		a2_symbol(\\Pi, \120),
  /* 81: Theta */       	a2_symbol(\\Theta, \121),
  /* 82: Rho */ 		a2_symbol(\\Rho, \122),
  /* 83: Sigma */       	a2_symbol(\\Sigma, \123),
  /* 84: Tau */ 		a2_symbol(\\Tau, \124),
  /* 85: Upsilon */     	a2_symbol(\\Upsilon, \125),
  /* 86: sigma1 */      	a2_symbol(\\varsigma, \126),
  /* 87: Omega */       	a2_symbol(\\Omega, \127),
  /* 88: Xi */ 		 	a2_symbol(\\Xi, \130),
  /* 89: Psi */ 		a2_symbol(\\Psi, \131),
  /* 90: Zeta */        	a2_symbol(\\Zeta, \132),
  /* 92: therefore */   	a2_symbol(\\therefore, \134),
  /* 94: perpendicular */       a2_symbol(\\perp, \136),
  /* 96: radicalex */   	a2_symbol(\\radicalex, \140),
  /* 97: alpha */       	a2_symbol(\\alpha, \141),
  /* 98: beta */        	a2_symbol(\\beta, \142),
  /* 99: chi */ 	 	a2_symbol(\\chi, \143),
  /* 100: delta */      	a2_symbol(\\delta, \144),
  /* 101: epsilon */    	a2_symbol(\\epsilon, \145),
  /* 102: phi */        	a2_symbol(\\phi, \146),
  /* 103: gamma */      	a2_symbol(\\gamma, \147),
  /* 104: eta */        	a2_symbol(\\eta, \150),
  /* 105: iota */       	a2_symbol(\\iota, \151),
  /* 106: phi1 */       	a2_symbol(\\phi, \152),
  /* 107: kappa */      	a2_symbol(\\kappa, \153),
  /* 108: lambda */     	a2_symbol(\\lambda, \154),
  /* 109: mu */	 		a2_symbol(\\mu, \155),
  /* 110: nu */	 		a2_symbol(\\nu, \156),
  /* 111: omicron */    	a2_symbol(\\omicron, \157),
  /* 112: pi */	 		a2_symbol(\\pi, \160),
  /* 113: theta */      	a2_symbol(\\theta, \161),
  /* 114: rho */        	a2_symbol(\\rho, \162),
  /* 115: sigma */      	a2_symbol(\\sigma, \163),
  /* 116: tau */        	a2_symbol(\\tau, \164),
  /* 117: upsilon */    	a2_symbol(\\upsilon, \165),
  /* 118: omega1 */     	a2_symbol(\\varpi, \166),
  /* 119: omega */      	a2_symbol(\\omega, \167),
  /* 120: xi */	 		a2_symbol(\\xi, \170),
  /* 121: psi */        	a2_symbol(\\psi, \171),
  /* 122: zeta */       	a2_symbol(\\zeta, \172),
  /* 126: similar */    	a2_symbol(\\sim, \176),
  /* 161: Upsilon1 */   	a2_symbol(\\varUpsilon, \241),
  /* 162: minute */     	a2_symbol(\\prime, \242),
  /* 163: lessequal */  	a2_symbol(\\leq, \243),
  /* 165: infinity */   	a2_symbol(\\infty, \245),
  /* 166: florin **********/   	a2_symbol(\\florin, \246),
  /* 167: club */       	a2_symbol(\\clubsuit, \247),
  /* 168: diamond */    	a2_symbol(\\diamondsuit, \250),
  /* 169: heart */      	a2_symbol(\\heartsuit, \251),
  /* 170: spade */      	a2_symbol(\\spadesuit, \252),
  /* 171: arrowboth */  	a2_symbol(\\leftrightarrow, \253),
  /* 172: arrowleft */  	a2_symbol(\\leftarrow, \254),
  /* 173: arrowup */    	a2_symbol(\\uparrow, \255),
  /* 174: arrowright */ 	a2_symbol(\\rightarrow, \256),
  /* 175: arrowdown */  	a2_symbol(\\downarrow, \257),
  /* 176: degree ********/     	a2_symbol(\\circ, \260),
  /* 177: plusminus */		a2_symbol(\\pm, \261),
  /* 179: greaterequal */       a2_symbol(\\geq, \263),
  /* 180: multiply */   	a2_symbol(\\times, \264),
  /* 181: proportional */       a2_symbol(\\propto, \265),
  /* 182: partialdiff */        a2_symbol(\\partial, \266),
  /* 183: bullet */    		a2_symbol(\\bullet, \267),
  /* 184: divide */     	a2_symbol(\\div, \270),
  /* 185: notequal */   	a2_symbol(\\neq, \271),
  /* 186: equivalence */        a2_symbol(\\equiv, \272),
  /* 187: approxequal */        a2_symbol(\\approx, \273),
  /* 188: ellipsis */   	a2_symbol(\\ldots, \274),
  /* 190: arrowhorizex */	a2_symbol(---, \276),
  /* 191: carriagereturn */     a2_symbol(\\carriagereturn, \277),
  /* 192: aleph */      	a2_symbol(\\aleph, \300),
  /* 193: Ifraktur */   	a2_symbol(\\Im, \301),
  /* 194: Rfraktur */   	a2_symbol(\\Re, \302),
  /* 195: weierstrass */        a2_symbol(\\wp, \303),
  /* 196: circlemultiply */     a2_symbol(\\otimes, \304),
  /* 197: circleplus */ 	a2_symbol(\\oplus, \305),
  /* 198: emptyset */  		a2_symbol(\\emptyset, \306),
  /* 199: intersection */       a2_symbol(\\cap, \307),
  /* 200: union */      	a2_symbol(\\cup, \310),
  /* 201: propersuperset */     a2_symbol(\\supset, \311),
  /* 202: reflexsuperset */     a2_symbol(\\supseteq, \312),
  /* 203: notsubset */  	a2_symbol(\\not\\subset, \313),
  /* 204: propersubset */       a2_symbol(\\subset, \314),
  /* 205: reflexsubset */       a2_symbol(\\subseteq, \315),
  /* 206: element */    	a2_symbol(\\in, \316),
  /* 207: notelement */ 	a2_symbol(\\not\\in, \317),
  /* 208: angle */      	a2_symbol(\\angle, \320),
  /* 209: gradient */   	a2_symbol(\\nabla, \321),
  /* 210: registerserif *****/  a2_symbol(\\register, \322),
  /* 211: copyrightserif ****/  a2_symbol(\\copyright, \323),
  /* 212: trademarkserif ****/  a2_symbol(\\trademark, \324),
  /* 213: product */    	a2_symbol(\\prod, \325),
  /* 214: radical */    	a2_symbol(\\surd, \326),
  /* 215: dotmath */    	a2_symbol(\\cdot, \327),
  /* 216: logicalnot */ 	a2_symbol(\\not, \330),
  /* 217: logicaland */ 	a2_symbol(\\wedge, \331),
  /* 218: logicalor */  	a2_symbol(\\vee, \332),
  /* 219: arrowdblboth */       a2_symbol(\\Leftrightarrow, \333),
  /* 220: arrowdblleft */       a2_symbol(\\Leftarrow, \334),
  /* 221: arrowdblup */ 	a2_symbol(\\Uparrow, \335),
  /* 222: arrowdblright */      a2_symbol(\\Rightarrow, \336),
  /* 223: arrowdbldown */       a2_symbol(\\Downarrow, \337),
  /* 224: lozenge *****/	a2_symbol(\\diamondsuit, \340),
  /* 225: angleleft */  	a2_symbol(\\langle, \341),
  /* 226: registersans ****/   	a2_symbol(\\register, \342),
  /* 227: copyrightsans ****/  	a2_symbol(\\copyright, \343),
  /* 228: trademarksans ****/  	a2_symbol(\\trademark, \344),
  /* 229: summation */  	a2_symbol(\\sum, \345),
  /* 233: bracketlefttp */      a2_symbol(\\lceil, \351),
  /* 235: bracketleftbt */      a2_symbol(\\lfloor, \353),
  /* 240: .notdef */    	a2_symbol(\\apple, \360),
  /* 241: angleright */ 	a2_symbol(\\rangle, \361),
  /* 242: integral */   	a2_symbol(\\int, \362),
  /* 249: bracketrighttp */     a2_symbol(\\rceil, \371),
  /* 251: bracketrightbt */     a2_symbol(\\rfloor, \373),
  UNULL
};
const unsigned char* prescript_specials [] = {
  /* There is no mode math in prescript */
  (ustring) "\\$", 	(ustring) "$", 	FONT_COURIER,
  (ustring) "$", 		UNULL, 	FONT_INVISIBLE,
  (ustring) "\\_", 	(ustring) "_",	FONT_COURIER,
  (ustring) "\\%", 	(ustring) "%", 	FONT_COURIER,
  (ustring) "\\&", 	(ustring) "&", 	FONT_COURIER,
  (ustring) "\\#", 	(ustring) "#", 	FONT_COURIER,
  /*
   * This is taken from the correspondance between font symbol
   * and LaTeX commands
   */
  /* 35: numbersign   	a2_symbol(\\#, \43),*/
  /* 37: percent      	a2_symbol(\\%, \45),*/
  /* 38: ampersand   	a2_symbol(\\&, \46),*/
  /* 40 parenleft */   		a2_symbol(`\\(', \50),
  /* 41 parenright */  		a2_symbol(`\\)', \51),
  /* 91: bracketleft */ 	a2_symbol(\\[, \133),
  /* 93: bracketright */        a2_symbol(\\], \135),
  /* 95: underscore */  	a2_symbol(\\_, \137),
  /* 123: braceleft */  	a2_symbol(\\{, \173),
  /* 124: bar */        	a2_symbol(\\|, \174),
  /* 125: braceright */ 	a2_symbol(\\}, \175),
  /* 189: arrowvertex */        a2_symbol(\\|, \275),
  UNULL
};
const char *  prescript_abbreviations[] = {
  "biftex", "bif", "pre", "ptf", "\0"
};
const unsigned char prescript_description [] = 
"This is prescript, a language of description of textual pages. "
"It provides by the use of LaTeX like commands, a way to describe the "
"pages that a2ps should produce. It can be a very good choice of "
"destination language for people who want to produce text to print "
"(e.g. pretty-printing, automating documentation etc.) "
"but who defenetely do not want to learn postscript, nor to require "
"the use of LaTeX."
"\n"
"It is also known as BifTeX (Basic Instruction From LaTeX), of ptf "
"(Poor Text Format)."
"\n"
"Symbol translation is always enabled in this mode.";
#define prescript_style { "prescript",  				\
  prescript_abbreviations, prescript_description, 			\
  CASE_SENSITIVE, prescript_chars_1, prescript_chars_2, EMPTY,		\
  prescript_symbols, prescript_specials, prescript_sequences, EMPTY, EMPTY }


/************************************************************************/
/*			Misceleanous				   	*/
/************************************************************************/
/*
 *		mail
 */
const unsigned char* mail_sequences [] = { 
  a2_sequence(`> ', COURIER, ITALIC, \n, ITALIC),
  a2_sequence(Subject:, BOLD, BOLD, \n, BOLD),
  a2_sequence(X-Sun-Data-Name:, BOLD, BOLD, \n, BOLD),
  UNULL
};
const unsigned char mail_characters [] = {
  ':', ':',
  '_', '_',
  '-', '-',
m4_dnl This is no longer useful
m4_dnl  '\300', '\326', 
m4_dnl  '\340', '\366', 	/* the following chars are used to avoid */
m4_dnl  '\371', '\375', 	/* that words are cut around non-ascii chars */
  '\0'
};
const unsigned char * mail_keywords [] = {
  /* headers of big interest */
  a2_keyword(BOLD, From:, To:, Date:, Date, Lines:, Organization:, Address:)

  /* headers of small interest */
  a2_keyword(ITALIC, Return-Path:, Received:, Sender:, Message-Id:,
Reply-To:, From, X-Mailer:, Status:, Content-Transfer-Encoding:,
Path:, Via:, Sent:, Original, Phase, Fruit, Sun, Lat, Buzzword,
Return, Posted, Telephone, Postal-Address, Origin, X-Sent-By-Nmail-V,
Resent, X-Location, Source, Mood, Neuron, Libi, X-HPMAIL, Mmdf,
Network-, Really-, Post, Message-, Relay-, Article-, Approved:, Xref:,
Transport-Options:, Ua-Content-Id:, Email-Version:, Errors-To:,
Autoforwarded:, Sensitivity:, Content-Identifier:, Content-Type:)

  /* X400 Headers */
  a2_keyword(ITALIC, X400-received:, X400-Recipients:,
X400-Mts-Identifiers:, X400-Content-Type:)

  /* X headers */
  a2_keyword(ITALIC, X-Face, X-Filter:, X-How-To-Reach-Us:, X-Char-Esc:,
X-Mts:, X-Comment:, X-Telephone:, X-Facsimile:, X-Sequence:, X-lines:,
Organisation:, Phone:, Telefax:, Warnings-To:, X-VM-v5-Data:,
X-Sun-Charset:, X-Sun-Data-Type:, X-Sun-Data-Description:,
X-Sun-Content-Lines:, MIME-Version:)
  UNULL
};
const char * mail_abbreviations[]= {
  "mail", "\0"
};
const unsigned char  mail_description [] = 
  "To use from elm and others, it is better to specify -kmailfolder, "
  "since the file sent to printer is no longer trully a mailfolder. "
  "It can also be nice to use -u and -H to specify the name of the "
  "mail box owner.";
#define mail_style { "mailfolder",  					\
  mail_abbreviations, mail_description, 				\
  CASE_SENSITIVE, mail_characters, mail_characters, mail_keywords,	\
  EMPTY, EMPTY, mail_sequences, EMPTY, EMPTY }

/*
 *		Postscript
 */
const unsigned char* postscript_sequences [] = { 
  a2_sequence(%!, ITALIC, EMPH, 	\n, ITALIC),
  a2_sequence(%%, ITALIC, EMPH, 	\n, ITALIC),
  a2_sequence(%, ITALIC, ITALIC, \n, ITALIC),
  a2_sequence(`(', courier, courier, `)', courier),
  UNULL
};
const unsigned char postscript_characters [] = {
  '_', '_',
  '\\', '\\',
  '\0'
};
const unsigned char* postscript_keywords [] = {
  a2_keyword(BOLD, add, arc, begin, bind, clip, charpath, closepath,
currentdict, curveto, def, dict, div, dup, end, exch, fill, for,
foreach, findfont, get, grestore, gsave, if, ifelse, index, length,
lineto, moveto, mul, neg, newpath, pop, put, restore, rlineto,
rmoveto, rotate, save, scale, scalefont, setfont, setgray,
setlinewidth, show, showpage, stringwidth, stroke, sub, translate)

  a2_keyword(italic, true, false)
   UNULL
};
const unsigned char* postscript_symbols [] = {
#if 0
  a2_and(&&),
  a2_or(||),
  a2_oplus(^^),
  a2_leq(<=),
  a2_geq(>=),
#endif
  a2_equiv(eq),
  a2_neq(ne),
  UNULL
};
const char * postscript_abbreviations[]= {
  "PostScript", "ps", "\0"
};
const unsigned char  postscript_description [] = "";
#define postscript_style { "postscript",				\
  postscript_abbreviations, postscript_description,			\
  CASE_SENSITIVE, postscript_characters, postscript_characters,		\
  postscript_keywords, postscript_symbols, EMPTY, postscript_sequences, EMPTY, EMPTY }

#ifdef HTML_STYLE
/*
 *		HTML
 * note: this is almost a joke since it does not work very well.
 */
const unsigned char* html_sequences [] = { 
  a2_sequence(<TITLE>, ITALIC, BOLD, </TITLE>, ITALIC),
  a2_sequence(<TT>, ITALIC, COURIER, </TT>, ITALIC),
  a2_sequence(%, ITALIC, ITALIC, \n, ITALIC),
  UNULL
};
const unsigned char html_characters [] = {
  '_', '_',
  '/', '/',
  '<', '<',
  '>', '>',
  '\0'
};
const unsigned char* html_keywords [] = {
  a2_keyword(ITALIC, <HTML>, </HTML>, <BODY>, </BODY>)
   UNULL
};
const char * html_abbreviations[]= {
  "\0"
};
const unsigned char  html_description[] = "";
#define html_style { "html", 				\
  html_abbreviations, html_description, 		\
  CASE_SENSITIVE, html_characters, html_characters,   	\
  html_keywords, EMPTY, EMPTY, html_sequences, EMPTY, EMPTY }
#endif

/************************************************************************/
/*				Shell-scripts			   	*/
/************************************************************************/
/*
 *		sh
 */
const unsigned char* sh_sequences [] = { 
  a2_sequence(#, ITALIC, ITALIC, \n, ITALIC),
  a2_sequence(\", COURIER, TIMES, \", COURIER),
  a2_sequence(\', COURIER, TIMES, \', COURIER),
  UNULL
};
const unsigned char* sh_verbatims [] = {
  (ustring) "\\\\", (ustring) "\\\"", (ustring) "\\\'", UNULL
};
const unsigned char sh_characters [] = {
  '_', '_',
  '/', '/', 
  '$', '$', 
  '\0'
};
const unsigned char sh_following_characters [] = {
  '_', '_',
  '/', '/', 
  '$', '$', 
  '#', '#', /* to avoid $# be understood as the beginning of a comment */
  '\0'
};
const unsigned char* sh_keywords [] = {
  a2_keyword(BOLD, for, in, do, done, case, esac, if, then, elif, else,
fi, while, break, continue, cd, echo, eval, exec, exit, export, read,
return, set, shift, test, times, trap, stop, type, umask, unset, wait)
   UNULL
};
const char * sh_abbreviations[]= {
  "c-shell", "jsh", "csh", "ksh", "bash", "shell", "\0"
};
const unsigned char  sh_description[] = "";
#define sh_style { "sh",					\
  sh_abbreviations, sh_description, 				\
  CASE_SENSITIVE, sh_characters, sh_following_characters,   	\
  sh_keywords, EMPTY, EMPTY, sh_sequences, sh_verbatims, EMPTY }

/*
 *		zsh
 */
const unsigned char* zsh_symbols [] = {
  a2_and(&&),
  a2_or(||),
  a2_oplus(^^),
  a2_neq(!=),
  a2_equiv(==),
  a2_leq(<=),
  a2_geq(>=),
  UNULL
};
const unsigned char* zsh_specials [] = {
  a2_not(!),
  UNULL
};
const unsigned char * zsh_keywords [] = {
   a2_keyword(BOLD, alias, autoload, bg, bindkey, break, builtin, bye,
cd, chdir, compctl, continue, declare, dirs, disable, disown, echo,
echotc, emulate, enable, eval, exit, export, false, fc, fg, functions,
getln, getopts, hash, history, integer, jobs, kill, let, limit, local,
log, logout, popd, print, pushd, pushln, pwd, r, read, readonly,
rehash, return, sched, set, setopt, shift, source, suspend, test,
times, trap, true, ttyctl, type, typeset, ulimit, umask, inalias,
unfunction, unhash, unlimit, unset, unsetopt, vared, wait, whence,
where, which, noglob, nocorrect, exec, command, if, then, elif, fi,
for, in, do, done, foreach, end, while, until, repeat, case, esac,
select, function, time, coproc)
  UNULL
};
const char * zsh_abbreviations[]= {
  "\0"
};
const unsigned char  zsh_description[] = "";
#define zsh_style { "zsh",				     	  	\
  zsh_abbreviations, zsh_description, 					\
  CASE_SENSITIVE, sh_characters, sh_following_characters,	       	\
  zsh_keywords, zsh_symbols, zsh_specials, sh_sequences, sh_verbatims, EMPTY }

/*
 *		Perl
 */
const unsigned char* perl_sequences [] = {
  a2_sequence(#, COURIER, ITALIC, \n, ITALIC),
  a2_sequence(\", COURIER, TIMES,  \", COURIER),
  a2_sequence(\', COURIER, TIMES,  \', COURIER),
  UNULL
};
const unsigned char perl_characters [] = {
  '_', '_',
  '\0'
};
const unsigned char* perl_keywords [] = {
   a2_keyword(BOLD, if, until, while, elsif, else, unless, for, foreach,
continue, exit, die, last, goto, next, redo, return, local, exec, sub,
do, dump, use, require, package, eval, my, BEGIN, END, CORE, __FILE__,
__LINE__, abs, accept, alarm, and, atan, bind, binmode, bless, caller,
chdir, chmod, chown, chr, chroot, close, closedir, cmp, connect,
continue, cos, crypt, dbmclose, dbmopen, die, dump, endgrent,
endhostent, endnetent, endprotoent, endpwent, endservent, eof, eq,
exec, exit, exp, fcntl, fileno, flock, fork, formline, ge, getc,
getgrent, getgrgid, getgrnam, gethostbyaddr, gethostbyname,
gethostent, getlogin, getnetbyaddr, getnetbyname, getnetent,
getpeername, getpgrp, getppid, getpriority, getprotobyname,
getprotobynumber, getprotoent, getpwent, getpwnam, getpwuid,
getservbyname, getservbyport, getservent, getsockname, getsockopt,
glob, gmtime, gt, hex, index, int, ioctl, join, kill, lc, lcfirst, le,
length, link, listen, localtime, log, lstat, lt, mkdir, msgctl,
msgget, msgrcv, msgsnd, ne, not, oct, open, opendir, or, ord, pack,
pipe, quotemeta, rand, read, readdir, readline, readlink, readpipe,
recv, ref, rename, require, reset, reverse, rewinddir, rindex, rmdir,
seek, seekdir, select, semctl, semget, semop, send, setgrent,
sethostent, setnetent, setpgrp, setpriority, setprotoent, setpwent,
setservent, setsockopt, shmctl, shmget, shmread, shmwrite, shutdown,
sin, sleep, socket, socketpair, sprintf, sqrt, srand, stat, substr,
symlink, syscall, sysread, system, syswrite, tell, telldir, time,
times, truncate, uc, ucfirst, umask, unlink, unpack, utime, values,
vec, wait, waitpid, wantarray, warn, write, x, xor, print)
   UNULL
};
const char * perl_abbreviations[]= {
  "pl", "pm", "\0"
};
const unsigned char  perl_description[] = "";
#define perl_style { "perl", 						\
  perl_abbreviations, perl_description, 				\
  CASE_SENSITIVE, perl_characters, perl_characters, perl_keywords,	\
  EMPTY, EMPTY, perl_sequences, sh_verbatims, EMPTY }


/************************************************************************/
/*			  Eiffel and eiffel-like	       	   	*/
/************************************************************************/
/*
 *		Eiffel
 */
const unsigned char* eiffel_sequences [] = {
  a2_sequence(--, ITALIC, ITALIC, \n, ITALIC),
  a2_sequence(\", COURIER, TIMES, \", COURIER),
  a2_sequence(\', COURIER, TIMES, \', COURIER),
  UNULL
};
const unsigned char* eiffel_verbatims [] = {
  (ustring) "%%", (ustring) "%\"", (ustring) "%'", UNULL
};
const unsigned char eiffel_characters [] = {
  '_', '_',
  '\0'
};
const unsigned char* eiffel_symbols [] = {
  (ustring)"or else", (ustring)"or else", FONT_BOLD,
  (ustring)"and then", (ustring)"and then", FONT_BOLD,
  a2_not(not), a2_or(or), a2_and(and), a2_imply(implies),
  UNULL
};
const unsigned char* eiffel_specials [] = {
  (ustring) ":=", (ustring) ":=",   FONT_COURIER,
  a2_equiv(=),
  a2_neq(/=),
  a2_leq(<=),
  a2_geq(>=),
  UNULL
};
const unsigned char* eiffel_keywords [] = {
  /* keywords */
  a2_keyword(BOLD, all, alias, as, and, check, class, current, debug,
deferred, do, else, elseif, end, ensure, expanded, export, external,
false, feature, from, if, implies, indexing, infix, inherit, inspect,
invariant, is, language, like, local, loop, none, not, creation,
obsolete, old, once, or, prefix, redefine, require, rename, rescue,
result, retry, select, separate, strip, then, true, undefine, unique,
until, variant, void, when, xor)

   /* some basic types */
 a2_keyword(ITALIC, bit, boolean, character, double, integer, pointer,
real, string)
   UNULL
};
const char * eiffel_abbreviations[] = {
  "e", "\0"
};
const unsigned char  eiffel_description[] = "";
#define eiffel_style { "eiffel",					\
  eiffel_abbreviations, eiffel_description, 				\
  CASE_INSENSITIVE, eiffel_characters,	eiffel_characters,		\
  eiffel_keywords,                                                     	\
  eiffel_symbols, eiffel_specials, eiffel_sequences, eiffel_verbatims, EMPTY }

/*
 *		Language of Assembly for Classes of Eiffel
 */
const unsigned char* lace_keywords [] = { 
  /* keywords */
  a2_keyword(BOLD, end, system, root, cluster, use, include, precompiled,
exclude, adapt, ignore, rename, as, default, option, collect,
assertion, debug, optimize, trace, yes, no, all, require, ensure,
invariant, loop, check, external, object, make, generate, visible,
creation, export)

   /* Languages */
  a2_keyword(ITALIC, eiffel, ada, pascal, fortran, c)
   UNULL
};
const char * lace_abbreviations[] = {
  "ace", "\0"
};
const unsigned char  lace_description[] = "";
#define lace_style { "lace", 						\
  lace_abbreviations, lace_description, 				\
  CASE_INSENSITIVE, eiffel_characters, eiffel_characters,		\
  lace_keywords, EMPTY, EMPTY, eiffel_sequences, eiffel_verbatims, EMPTY }

/************************************************************************/
/*				C and C-like			   	*/
/************************************************************************/
m4_dnl Definition of some common stuff between c-like languages
m4_define(`a2_preprocessor_keywords',
`/* Preprocessor */
  a2_keyword(BOLD, #include, #define, #undef, #pragma, #if, #ifdef,
#ifndef, #elif, #else, #error, #line, #ex, #endif, defined, 
# include, # define, # include, # if, # ifdef, # endif,
#  include, #  define, #  include, #  if, #  ifdef, #  endif)') m4_dnl
m4_define(`c_basic_keywords',
`a2_preprocessor_keywords

  /* simple types */
  a2_keyword(ITALIC, double, enum, void, int, long, FILE, struct, char,
signed, float, short, unsigned)

  /* core of the keywords */
  a2_keyword(BOLD, extern, const, register, return, continue, for, auto,
switch, typedef, union, goto, sizeof, volatile, do, static, while,
NULL, FILE, case, default, break, if, for, while, else)')m4_dnl

 
/*
 *		C
 */
const unsigned char* c_sequences [] = {
  a2_sequence(/*, ITALIC, ITALIC, */, ITALIC),
  a2_sequence(\", COURIER, TIMES, \", COURIER),
  a2_sequence(\', COURIER, TIMES, \', COURIER),
  UNULL
};
const unsigned char c_characters [] = {
  '_', '_',
  '#', '%',
  '\0'
};
const unsigned char* c_specials [] = {
  a2_rightarrow(->),
  a2_and(&&),
  a2_or(||),
  a2_neq(!=),
  a2_equiv(==),
  a2_leq(<=),
  a2_geq(>=),
  a2_not(!),
  UNULL
};
const unsigned char* c_keywords [] = {
  c_basic_keywords
  UNULL 
}; 
const char * c_abbreviations[]= {
  "h", "i", "\0"
};
const unsigned char  c_description[] = "";
#define c_style {"c", 						\
  c_abbreviations, c_description, 				\
  CASE_SENSITIVE, c_characters, c_characters, c_keywords,	\
  EMPTY, c_specials, c_sequences, sh_verbatims, EMPTY }

/*
 *		c++
 */
const unsigned char* cpp_sequences [] = {
  a2_sequence(/*, ITALIC, ITALIC, */, ITALIC),
  a2_sequence(//, ITALIC, ITALIC, \n, ITALIC),
  a2_sequence(\", COURIER, TIMES, \", COURIER),
  a2_sequence(\', COURIER, TIMES, \', COURIER),
  UNULL
};
const unsigned char* cpp_keywords [] = {
  c_basic_keywords

  /* c++'s own keywords */
  a2_keyword(BOLD, new, delete, this, operator, class, public, protected,
private, virtual, friend, inline, template, dynamic, typeof, all,
except, exception, raise, raises, reraises, try, asm, catch, overload)
   UNULL
};
const char * cpp_abbreviations[]= {
  "h++", "C", "H", "cc", "hh", "cpp", "hpp", "cxx", "hxx", "pdb", "\0"
};
const unsigned char  cpp_description[] = "";
#define cpp_style { "c++",						\
  cpp_abbreviations, cpp_description, 					\
  CASE_SENSITIVE, c_characters, c_characters, cpp_keywords,		\
  EMPTY, c_specials, cpp_sequences, sh_verbatims, EMPTY }

/*
 *		o2c
 */
const unsigned char* o2c_sequences [] = {
  /* "real" sequences */
  a2_sequence(/*, ITALIC, ITALIC, */, ITALIC),
  a2_sequence(\", COURIER, TIMES,  \", COURIER),
  a2_sequence(\', COURIER, TIMES,  \', COURIER),

  /* Highlight special declarations */
  a2_sequence(application, BOLD, BOLD, \n, COURIER),
  a2_sequence(class, BOLD, BOLD, \n, COURIER),
  a2_sequence(method body, BOLD, BOLD, `in ', BOLD),
  a2_sequence(transaction body, BOLD, BOLD, `in ', BOLD),
  a2_sequence(program body, BOLD, BOLD, `in ', BOLD),
  a2_sequence(program public, BOLD, BOLD, `in ', BOLD),
  UNULL
};
const unsigned char* o2c_keywords [] = {
  c_basic_keywords

  /* o2c's own keywords */
  a2_keyword(BOLD, class, inherit, public, application, public, modify,
end, program, body, method, o2, in, new, o2query, name, function,
abort, commit, quit, validate, schema, base)
  UNULL
};
const char * o2c_abbreviations[] = {
  "o2", "\0"
};
const unsigned char  o2c_description[] = "";
#define o2c_style { "o2c",						\
  o2c_abbreviations, o2c_description, 					\
  CASE_SENSITIVE, c_characters, c_characters, o2c_keywords,		\
    EMPTY, c_specials, o2c_sequences, sh_verbatims, EMPTY }


/************************************************************************/
/*				Tcl & Tk			   	*/
/************************************************************************/
/*
 * 		TCL
 */
const unsigned char* tcl_specials [] = {
  a2_and(&&),
  a2_or(||),
  a2_neq(!=),
  a2_equiv(==),
  a2_leq(<=),
  a2_geq(>=),
  a2_not(!),
  UNULL
};
const unsigned char tcl_characters [] = {
  '-', '.',
  '_', '_',
  '#', '%',
  '\0'
};
const unsigned char* tcl_sequences [] = { 
  a2_sequence(#, ITALIC, ITALIC, \n, ITALIC),
  a2_sequence(\", COURIER, TIMES,  \", COURIER),
  UNULL
};
const unsigned char * tcl_keywords [] = {
  a2_keyword(BOLD, append, array, break, case, catch, cd, close, concat,
continue, eof, error, eval, exec, exit, expr, file, flush, for,
foreach, format, gets, glob, global, history, if, incr, info, join,
lappend, library, lindex, linsert, list, llength, lrange, lreplace,
lsearch, lsort, open, pid, proc, puts, pwd, read, regexp, regsub,
rename, return, scan, seek, set, source, split, string, switch, tell,
then, time, trace, unknown, unset, uplevel, upvar, while, elseif,
else, default)
  UNULL
};
const char * tcl_abbreviations[]= {
  "tclscript", "\0"
};
const unsigned char  tcl_description[] = "";
#define tcl_style { "tcl", 						\
  tcl_abbreviations, tcl_description, 					\
  CASE_SENSITIVE, tcl_characters, tcl_characters, tcl_keywords, 	\
  EMPTY, tcl_specials, tcl_sequences, sh_verbatims, EMPTY }

/*
 * 		tk
 */
const unsigned char* tk_keywords [] = {
  a2_keyword(BOLD, append, array, break, case, catch, cd, close, concat,
continue, eof, error, eval, exec, exit, expr, file, flush, for,
foreach, format, gets, glob, global, history, if, incr, info, join,
lappend, library, lindex, linsert, list, llength, lrange, lreplace,
lsearch, lsort, open, pid, proc, puts, pwd, read, regexp, regsub,
rename, return, scan, seek, set, source, split, string, switch, tell,
then, time, trace, unknown, unset, uplevel, upvar, while, elseif,
else, default, after, bind, button, canvas, checkbutton, destroy,
dialog, entry, exit, focus, frame, grab, label, lbSingSel, listbox,
lower, menu, menubar, menubutton, message, option, options, pack,
place, radiobutton, raise, scale, scrollbar, selection, send, text,
tkerror, tkwait, toplevel, update, winfo, wm)
   UNULL
};
const char * tk_abbreviations[]= {
  "wish", "\0"
};
const unsigned char  tk_description[] = "";
#define tk_style { "tk",  						\
  tk_abbreviations, tk_description, 					\
  CASE_SENSITIVE, tcl_characters, tcl_characters, tk_keywords, 		\
  EMPTY, c_specials, tcl_sequences, sh_verbatims, EMPTY }


/************************************************************************/
/*			Object-oriented languages		   	*/
/************************************************************************/
/*
 *		Claire
 */
const unsigned char* claire_sequences [] = {
  a2_sequence(;;, COURIER, ITALIC, \n, ITALIC),
  a2_sequence(//*, ITALIC, EMPH,   *//, ITALIC),
  a2_sequence(//, COURIER, ITALIC, \n, ITALIC),
  a2_sequence(\", COURIER, TIMES,  \", COURIER),
  a2_sequence(\', COURIER, TIMES,  \', COURIER),
  UNULL
};
const unsigned char claire_first_characters [] = {
  '!', '!', 
  '%', '&',
  '*', '+',
  '-', '-',
  '/', '/',
  '^', '_',
  '<', '>',
  '|', '|', 
  '\0'
};
const unsigned char claire_following_characters [] = {
  '!', '!', 
  '%', '\'', /* ' may be used like x' := x + 1 */
  '*', '+',
  '-', '-',
  '/', '/',
  '^', '_',
  '<', '>',
  '|', '|', 
  '\0'
};
const unsigned char* claire_symbols [] = {
  a2_symbol(forall, \"),
  a2_symbol(exists, $),
  a2_symbol(%, \316),
  (ustring) ":=", (ustring) ":=",   FONT_COURIER,
  a2_equiv(=),
  a2_neq(!=),
  a2_leq(<=),
  a2_geq(>=),
  a2_rightarrow(->),
  a2_imply(=>),
  a2_symbol(U, \310),
  a2_not(not),
  UNULL
};
const unsigned char* claire_specials [] = {
  a2_symbol({}, \306),	/* empty set */
  UNULL
};
const unsigned char* claire_keywords [] = {
  a2_keyword(BOLD, forall, none, catch, in, as, printf, assert, return,
break, trace, else, for, case, while, until, let, when, try, if, Zif,
exists, <:, =>, ->, ::)
  UNULL
};
const char * claire_abbreviations[]= {
  "cl", "\0"
};
const unsigned char  claire_description[] =
"CLAIRE is a high-level functional and object-oriented language with advanced rule processing capabilities. It is intended to allow the programmer to express complex algorithms with fewer lines and in an elegant and readable manner. \n"
"To provide a high degree of expressivity, CLAIRE uses: \n"
" - A very rich type system including type intervals and second-order types (with dual static/dynamic typing),\n"
" - Parametric classes and methods, \n"
" - An object-oriented logic with set extensions, \n"
" - Dynamic versioning that supports easy exploration of search spaces. \n"
" To achieve its goal of readability, CLAIRE uses \n"
" - set-based programming with an intuitive syntax, \n"
" - simple-minded object-oriented programming, \n"
" - truly polymorphic and parametric functional programming, \n"
" - a powerful-yet-readable extension of DATALOG to express logical conditions, \n"
" - an entity-relation approach with explicit relations, inverses, unknown values and relational\n"
" - operations. \n"
"More information on claire can be found on:\n"
"http://www.ens.fr/~laburthe/claire.html\n";
#define claire_style {"claire", 				\
  claire_abbreviations, claire_description, 		\
  CASE_SENSITIVE, claire_first_characters, 			\
  claire_following_characters,	claire_keywords,		\
  claire_symbols, claire_specials, claire_sequences, sh_verbatims, EMPTY }

/*
 *		Java
 */
const unsigned char java_characters_1 [] = {
  '_', '_',
  '#', '%',
  '\0'
};
const unsigned char java_characters_2 [] = {
  '.', '.', 
  '_', '_',
  '#', '%',
  '\0'
};
const unsigned char* java_sequences [] = {
  /* doc. comments */
  a2_sequence(/**, ITALIC, EMPH,  */, ITALIC),
  a2_sequence(/*, ITALIC, ITALIC, */, ITALIC),
  a2_sequence(//, ITALIC, ITALIC, \n, ITALIC),
  a2_sequence(\", COURIER, TIMES, \", COURIER),
  UNULL
};
const unsigned char* java_keywords [] = {
  a2_keyword(BOLD, one, of, abstract, default, if, private, throw,
boolean, do, implements, protected, throws, break, double, import,
public, transient, byte, else, instanceof, return, try, case, extends,
int, short, void, catch, final, interface, static, volatile, char,
finally, long, super, while, class, float, native, switch, const, for,
new, synchronized, continue, goto, package, this)
  UNULL
};
const char * java_abbreviations[]= {
  "\0"
};
const unsigned char  java_description[] = "";
#define java_style {"java",						\
  java_abbreviations, java_description,			 		\
  CASE_SENSITIVE, java_characters_1, java_characters_2,	java_keywords,	\
  EMPTY, c_specials, java_sequences, sh_verbatims, EMPTY }


/*
 *		Ada
 */
const unsigned char* ada_sequences [] = {
  a2_sequence(--, ITALIC, ITALIC,	\n, ITALIC),
  a2_sequence(\", COURIER, TIMES,	\", COURIER),
  a2_sequence(\', COURIER, TIMES,	\', COURIER),
  UNULL
};
const unsigned char* ada_verbatims [] = {
  (ustring) "\'\'\'", UNULL
};
const unsigned char* ada_escapes [] = {
  (ustring) "\"\"", (ustring) "\\\\", (ustring) "\\\'", UNULL
};
const unsigned char ada_1_characters [] = {
  '_', '_',
  '\0'
};
const unsigned char ada_2_characters [] = {
  '_', '_',
  '\'', '\'',           /*  L'First  is not opening in ada */
  '\0'
};
const unsigned char* ada_symbols [] = {
#if 0	/* most people do not want them */
  "and then", "and then", FONT_BOLD,	/* protect these two */
  "or else", "or else", FONT_BOLD,
  a2_and(and),
  a2_or(or),
  a2_not(not),
#endif
  UNULL
};
const unsigned char* ada_specials [] = {
  a2_neq(!=),
  a2_equiv(==),
  a2_leq(<=),
  a2_geq(>=),
  a2_imply(=>),
  UNULL
};
const unsigned char* ada_keywords [] = {
  a2_keyword(BOLD, abort, else, new, return, abs, elsif, not, reverse,
abstract, end, null, accept, entry, select, access, exception,
separate, aliased, exit, of, subtype, all, or, and, for, others,
tagged, array, function, out, task, at, terminate, generic, package,
then, begin, goto, pragma, type, body, private, if, procedure, case,
in, protected, until, constant, is, use, raise, declare, range, when,
delay, limited, record, while, delta, loop, rem, with, digits,
renames, do, mod, requeue, xor)
   UNULL 
}; 
const char * ada_abbreviations[]= {
  "adb", "ads", "\0"
};
const unsigned char  ada_description[] = "";
#define ada_style { "ada",						\
  ada_abbreviations, ada_description, 					\
  CASE_SENSITIVE, ada_1_characters, ada_2_characters, ada_keywords,	\
  ada_symbols, ada_specials, ada_sequences, ada_verbatims, ada_escapes }

/*
 *		Sather
 */
const unsigned char* sather_sequences [] = {
  a2_sequence(--, ITALIC, ITALIC, \n, ITALIC),
  a2_sequence(\", COURIER, TIMES, \", COURIER),
  a2_sequence(\', COURIER, TIMES, \', COURIER),
  UNULL
};
const unsigned char sather_1_characters [] = {
  '_', '_',
  '\0'
};
const unsigned char sather_2_characters [] = {
  '_', '_',
  '!', '!',
  '\0'
};
const unsigned char* sather_keywords [] = {
  /* keywords */
  a2_keyword(BOLD, abstract, and, any, assert, attr, bind, break!,
builtin, case, class, clusters, clusters!, cohort, const, else, elsif,
end, exception, external, false, far, fork, guard, if, immutable,
inout, include, initial, is, ITER, lock, loop, near, new, once, or,
out, par, parloop, post, pre, private, protect, quit, raise, readonly,
result, return, ROUT, SAME, self, shared, sync, then, true, typecase,
unlock, until!, void, when, while!, with, yield)

  /* Built-in classes */
 a2_keyword(ITALIC, BOOL, CHAR, STR, INT, INTI, FLT, FLTD, FLTI)

  /* Interfacing with fortran */
  a2_keyword(ITALIC, F_REAL, F_DOUBLE, F_INTEGER, F_COMPLEX,
F_DOUBLE_COMPLEX, F_LOGICAL, F_CHARACTER, F_REAL_ARR, F_DOUBLE_ARR,
F_INTEGER_ARR, F_COMPEX_ARR, F_DOUBLE_COMPLEX_ARR, F_LOGICAL_ARR)

  /* Interfacing with ANSI C */
  a2_keyword(ITALIC, C_CHAR, C_UNSIGNED_CHAR_PTR, C_UNSIGNED_CHAR,
C_SIGNED_CHAR_PTR, C_SIGNED_CHAR, C_SHORT_PTR, C_SHORT, C_INT_PTR,
C_INT, C_LONG_PTR, C_LONG, C_UNSIGNED_SHORT_PTR, C_UNSIGNED_SHORT,
C_UNSIGNED_INT_PTR, C_UNSIGNED_INT, C_UNSIGNED_LONG_PTR,
C_UNSIGNED_LONG, C_FLOAT_PTR, C_FLOAT, C_DOUBLE_PTR, C_DOUBLE,
C_LONG_DOUBLE_PTR, C_LONG_DOUBLE, C_SIZE_T, C_PTR, C_PTRDIFF_T,
C_CHAR_PTR)
  UNULL 
}; 
const unsigned char* sather_symbols [] = {
  a2_and(and),
  a2_or(or),
  UNULL
};
const unsigned char* sather_specials [] = {
  a2_neq(/=),
  a2_leq(<=),
  a2_geq(>=),
  UNULL
};
const char * sather_abbreviations[]= {
  "sa", "\0"
};
const unsigned char  sather_description[] = "";
#define sather_style { "sather", 					\
  sather_abbreviations, sather_description, 				\
  CASE_SENSITIVE, sather_1_characters, sather_2_characters, sather_keywords, \
  sather_symbols, sather_specials, sather_sequences, sh_verbatims, EMPTY }

/*
 *		Python
 */
const unsigned char* python_sequences [] = {
  a2_sequence(#, ITALIC, ITALIC, \n, ITALIC),
  a2_sequence(\"\"\", COURIER, TIMES, \"\"\", COURIER),
  a2_sequence(\", COURIER, TIMES, \", COURIER),
  a2_sequence(\', COURIER, TIMES, \', COURIER),
  UNULL
};
const unsigned char python_characters [] = {
  '_', '_',
  '\0'
};
const unsigned char* python_symbols [] = {
  a2_not(not),
  a2_and(and),
  a2_or(or),
  UNULL
};
const unsigned char* python_specials [] = {
  a2_neq(<>),
  a2_neq(!=),
  a2_leq(<=),
  a2_geq(>=),
  a2_equiv(==),
  UNULL
};
const unsigned char* python_keywords [] = {
 a2_keyword(BOLD, and, elif, from, lambda, return, break, else, global,
not, try, class, except, if, or, while, continue, exec, import, pass,
def, finally, in, print, del, is, raise, for)
  UNULL 
}; 
const char * python_abbreviations[]= {
  "pythonscript", "py", "\0"
};
const unsigned char  python_description[] = "";
#define python_style { "python", 					\
  python_abbreviations, python_description, 				\
  CASE_SENSITIVE, python_characters, python_characters, python_keywords, \
  python_symbols, python_specials, python_sequences, sh_verbatims, EMPTY }

/************************************************************************/
/*			Functional languages			   	*/
/************************************************************************/
/*
 *		caml
 */
const unsigned char* caml_sequences [] = {
  a2_sequence(`(*', COURIER, ITALIC,  `*)', COURIER),
  a2_sequence(\", COURIER, TIMES,  \", COURIER),
  /* a2_sequence(\', COURIER, TIMES,  \', COURIER),*/
  UNULL
};
const unsigned char caml_characters_1 [] = {
  '_', '_',
  '!', '!',
  '\0'
};
const unsigned char caml_characters_2 [] = {
  '_', '_',
  '\'', '\'',
  '!', '!',
  '\0'
};
const unsigned char* caml_symbols [] = {
  a2_not(not),
  a2_and(and),
  a2_or(or),
  UNULL
};
const unsigned char* caml_specials [] = {
  a2_neq(<>),
  a2_rightarrow(->),
  a2_leq(<=),
  a2_geq(>=),
  UNULL
};
const unsigned char* caml_keywords [] = {
  a2_keyword(BOLD, and, else, as, begin, do, done, downto, end,
exception, for, fun, function, if, in, let, match, mutable, not, of,
or, prefix, rec, then, to, try, type, value, where, while, with, int,
char, string, float, unit, list, raise, bool, vect)
   UNULL
};
const char * caml_abbreviations[]= {
  "ml", "mli", "mll", "\0"
};
const unsigned char  caml_description[] =
  "This style should also suit other versions of ML (caml light, SML etc.)\n";
#define caml_style { "caml", 					\
  caml_abbreviations, caml_description, CASE_INSENSITIVE,	\
  caml_characters_1, caml_characters_2, caml_keywords,		\
  caml_symbols, caml_specials, caml_sequences, sh_verbatims, EMPTY }

/*
 *		common-lisp
 */
const unsigned char* clisp_sequences [] = {
  /* comments */
  a2_sequence(;, ITALIC, ITALIC,  \n, COURIER),
  /* function declaration */
  a2_sequence(`(defun ', BOLD, EMPH, ` ', COURIER),
  /* strings*/
  a2_sequence(\", COURIER, TIMES, \", COURIER),
  UNULL
};
const unsigned char clisp_characters [] = {
  '_', '_',
  '-', '-',
  '\0'
};
const unsigned char* clisp_symbols [] = {
  a2_symbol(lambda, l),
  UNULL
};
const unsigned char* clisp_keywords [] = {
  a2_keyword(BOLD, or, and, cond, let, when, if, unless, defvar, setf, progn)
   UNULL
};
const char * clisp_abbreviations[]= {
  "el", "l", "lisp", "lsp", "clisp", "\0"
};
const unsigned char  clisp_description[] = "";
#define clisp_style { "common-lisp",					\
  clisp_abbreviations, clisp_description, 				\
  CASE_INSENSITIVE, clisp_characters, clisp_characters, clisp_keywords,	\
  clisp_symbols, EMPTY, clisp_sequences, sh_verbatims, EMPTY }

/*
 *		Scheme as defined at 
 * http://www-swiss.ai.mit.edu/emacs-html.local/scheme_toc.html
 */
const unsigned char* scheme_sequences [] = {
  /* comments */
  a2_sequence(;, ITALIC, ITALIC,  \n, COURIER),
  /* multiple line comments */
  a2_sequence(#|, ITALIC, ITALIC,  |#, COURIER),
  /* strings*/
  a2_sequence(\", COURIER, TIMES, \", COURIER),
  UNULL
};
const unsigned char scheme_characters [] = {
  '!', '!',
  '#', '&',	/* # $ % & */
  '*', '+', 	/* * + */
  '-', '/',	/* - . / */
  '<', '@', 	/* < = > ? @ */
  '_', '_',
  '\0'
};
const unsigned char* scheme_symbols [] = {
  a2_symbol(lambda, l),
  UNULL
};
const unsigned char* scheme_keywords [] = {
  a2_keyword(BOLD, access, define-syntax, macro, and, delay,
make-environment, begin, do, named-lambda, bkpt, fluid-let, or, case,
if, quasiquote, cond, in-package, quote, cons-stream, lambda,
scode-quote, declare, let, sequence, default-object?, let*, set!,
define, let-syntax, the-environment, define-integrable, letrec,
unassigned?, define-macro, local-declare, using-syntax,
define-structure)
  /* truth values */
  a2_keyword(EMPH, #f, #t)
   UNULL
};
const char * scheme_abbreviations[]= {
  "scm", "\0"
};
const unsigned char  scheme_description[] = "";
#define scheme_style { "scheme", 					\
  scheme_abbreviations, scheme_description, 				\
  CASE_INSENSITIVE, scheme_characters, scheme_characters, scheme_keywords,\
  scheme_symbols, EMPTY, scheme_sequences, sh_verbatims, EMPTY }

/*
 *		coq 5.10
 */
const unsigned char* coq_sequences [] = {
  a2_sequence(`(*', COURIER, ITALIC, `*)', COURIER),
  a2_sequence(\", COURIER, TIMES, \", COURIER),
  /*  "\'", "\'", FONT_COURIER, FONT_TIMES, "\'", "\'", FONT_COURIER,*/
  /* Definition of the section is emphasized */
  a2_sequence(Section, BOLD, EMPH, ., COURIER),
  a2_sequence(End, BOLD, EMPH, ., COURIER),
  UNULL
};
const unsigned char coq_characters [] = {
  '_', '_',
  '!', '!',
  '\0'
};
const unsigned char* coq_symbols [] = {
  a2_not(not),
  a2_and(and),
  a2_or(or),
  UNULL
};
const unsigned char* coq_specials [] = {
  a2_neq(<>),
  a2_rightarrow(->),
  a2_leq(<=),
  a2_geq(>=),
  UNULL
};
const unsigned char * coq_keywords [] = {
  a2_keyword(BOLD, Require, Declare)

  a2_keyword(ITALIC, with)
  
  a2_keyword(BOLD, Variable, Inductive, CoInductive, Fixpoint,
CoFixpoint, Definition, Lemma, Theorem, Axiom, Local, Save, Grammar,
Syntax)
  /* Tactics */
  a2_keyword(BOLD, Intro, Trivial, Qed, Intros, Symmetry, Simpl, Rewrite,
Apply, Elim, Assumption, Left, Cut, Case, Auto, Unfold, Exact, Right)
  /* Types */
  a2_keyword(ITALIC, Set)
   UNULL
};
const char * coq_abbreviations[] = {
  "coq", "v", "\0"
};
const unsigned char coq_description[] =
"This style is devoted to the Coq v 5.10 vernacular language.";
#define coq_style { "coq-vernacular", 				\
  coq_abbreviations, coq_description, 				\
  CASE_SENSITIVE, coq_characters, coq_characters, coq_keywords,	\
  coq_symbols, coq_specials, coq_sequences, sh_verbatims, EMPTY }

/************************************************************************/
/*			  Modula              			   	*/
/************************************************************************/
/*
 *		Pascal
 */
const unsigned char* pascal_sequences [] = {
  /* comments */
  a2_sequence(`(*', COURIER, ITALIC, `*)', COURIER), 
  a2_sequence(`{', COURIER, ITALIC, `}', COURIER), 
  /* char and strings litteral */
  a2_sequence(\', COURIER, TIMES, \', COURIER),
  /* Sections in the source file */
  a2_sequence(unit , EMPH, EMPH, \n, EMPH),
  a2_sequence(interface, EMPH, EMPH, \n, EMPH),
  a2_sequence(implementation, EMPH, EMPH, \n, EMPH),
  a2_sequence(program , EMPH, EMPH, \n, EMPH),
  UNULL
};
const unsigned char pascal_characters [] = {
  '_', '_',
  '\0'
};
const unsigned char* pascal_symbols [] = {
  a2_symbol(in, \316),
  a2_not(not),
  a2_and(and),
  a2_or(or),
  UNULL
};
const unsigned char* pascal_specials [] = {
  a2_rightarrow(->),
  a2_leq(<=),
  a2_geq(>=),
  (ustring) ":=", (ustring) ":=",   FONT_COURIER,	/* to avoid the change of = in := */
  a2_neq(<>),
  a2_equiv(=),
  UNULL
};
const unsigned char* pascal_keywords [] = {
  /* Pascal keywords */
  a2_keyword(BOLD, and, array, begin, constructor, const, dec, downto,
do, else, end, exit, false, file, for, function, goto, halt, if, inc,
in, label, nil, not, object, of, or, packed, procedure, readln, read,
record, repeat, set, shl, shr, then, to, true, type, until, uses, var,
while, with, write, writeln, xor)
  /* Pascal reserved identifiers */
  a2_keyword(ITALIC, abs, boolean, byte, div, integer, length, mod,
odd, pointer, real, registers, string, text, trunc, word)
  UNULL
};
const char * pascal_abbreviations[]= {
  "pas", "p", "\0"
};
const unsigned char  pascal_description[] =
  "The standard Pascal is covered by this style. But some extension have been "
  "added too, hence modern Pascal programs should be correctly handled.";
#define pascal_style { "pascal",					\
  pascal_abbreviations, pascal_description, 				\
  CASE_INSENSITIVE, pascal_characters, pascal_characters, pascal_keywords, \
  pascal_symbols, pascal_specials, pascal_sequences, sh_verbatims, EMPTY }

/*
 *		Modula-3
 */
const unsigned char* modula3_sequences [] = {
  /* comments */
  a2_sequence(`(*', COURIER, ITALIC, `*)', COURIER), 
  /* strings litteral */
  a2_sequence(\", COURIER, TIMES, \", COURIER),
  /* char litteral */
  a2_sequence(\', COURIER, TIMES, \', COURIER),
  UNULL
};
const unsigned char modula3_characters [] = {
  '_', '_',
  '\0'
};
const unsigned char* modula3_symbols [] = {
  a2_symbol(IN, \316), 	/* is member of */
  a2_not(NOT),
  a2_and(AND),
  a2_or(OR),
  UNULL
};
const unsigned char* modula3_specials [] = {
  a2_rightarrow(->),
  a2_leq(<=),
  a2_geq(>=),
  (ustring) ":=", (ustring) ":=",   FONT_COURIER,	/* to avoid the change of = in := */
  a2_neq(#),
  a2_equiv(=),
  UNULL
};
const unsigned char* modula3_keywords [] = {
  /* Modula 3 keywords */
  a2_keyword(BOLD, AND, DO, FROM, NOT, REPEAT, UNTIL, ANY, ELSE, GENERIC,
OBJECT, RETURN, UNTRACED, ARRAY, ELSIF, IF, OF, REVEAL, VALUE, AS,
END, IMPORT, OR, ROOT, VAR, BEGIN, EVAL, IN, OVERRIDES, SET, WHILE,
BITS, EXCEPT, INTERFACE, PROCEDURE, THEN, WITH, BRANDED, EXCEPTION,
LOCK, RAISE, TO, BY, EXIT, LOOP, RAISES, TRY, CASE, EXPORTS, METHODS,
READONLY, TYPE, CONST, FINALLY, MOD, RECORD, TYPECASE, DIV, FOR,
MODULE, REF, UNSAFE)
  /* Modula 3 reserved identifiers */
  a2_keyword(ITALIC, ABS, BYTESIZE, EXTENDED, INTEGER, MIN, NUMBER, TEXT,
ADDRESS, CARDINAL, FALSE, ISTYPE, MUTEX, ORD, TRUE, ADR, CEILING,
FIRST, LAST, NARROW, REAL, TRUNC, ADRSIZE, CHAR, FLOAT, LONGREAL, NEW,
REFANY, TYPECODE, BITSIZE, DEC, FLOOR, LOOPHOLE, NIL, ROUND, VAL,
BOOLEAN, DISPOSE, INC, MAX, NULL, SUBARRAY)
  UNULL
};
const char * modula3_abbreviations[]= {
  "m3", "\0"
};
const unsigned char  modula3_description[] = "";
#define modula3_style { "modula-3",					\
  modula3_abbreviations, modula3_description, 				\
  CASE_SENSITIVE, modula3_characters, modula3_characters, modula3_keywords, \
  modula3_symbols, modula3_specials, modula3_sequences, sh_verbatims, EMPTY }

/*
 *		Oberon
 */
const unsigned char* oberon_sequences [] = {
  /* comments */
  a2_sequence(`(*', COURIER, ITALIC, `*)', COURIER), 
  /* strings litteral */
  a2_sequence(\", COURIER, TIMES,  \", COURIER),
  /* char litteral */
  a2_sequence(\', COURIER, TIMES,  \', COURIER),
  UNULL
};
const unsigned char oberon_characters [] = {
  '\0'
};
const unsigned char* oberon_symbols [] = {
  a2_symbol(IN, \316),
  a2_not(NOT),
  a2_and(AND),
  a2_or(OR),
  UNULL
};
const unsigned char* oberon_specials [] = {
  a2_rightarrow(->),
  a2_leq(<=),
  a2_geq(>=),
  (ustring) ":=", (ustring) ":=",   FONT_COURIER,	/* to avoid the change of = in := */
  a2_neq(#),
  a2_equiv(=),
  UNULL
};
const unsigned char* oberon_keywords [] = {

  a2_keyword(BOLD, ARRAY, IS, TO, BEGIN, LOOP, TYPE, CASE, MOD, UNTIL,
CONST, MODULE, VAR, DIV, NIL, WHILE, DO, OF, WITH, ELSE, OR, ELSIF,
POINTER, END, PROCEDURE, EXIT, RECORD, IF, REPEAT, IMPORT, RETURN, IN,
THEN)
  /* builtins */
  a2_keyword(ITALIC, ABS, LEN, ASH, LONG, BOOLEAN, LONGINT, BYTE,
LONGREAL, CAP, MAX, CHAR, MIN, CHR, NEW, DEC, ODD, ENTIER, ORD, EXCL,
REAL, FALSE, SET, HALT, SHORT, INC, SHORTINT, INCL, SIZE, INTEGER,
TRUE)
  UNULL
};
const char * oberon_abbreviations[]= {
  "\0"
};
const unsigned char  oberon_description[] = "";
#define oberon_style { "oberon",					\
  oberon_abbreviations, oberon_description, 				\
  CASE_SENSITIVE, oberon_characters, oberon_characters, oberon_keywords, \
  oberon_symbols, oberon_specials, oberon_sequences, sh_verbatims, EMPTY }
     


/************************************************************************/
/*			Specification languages			   	*/
/************************************************************************/
/*
 *		Promela
 */
const unsigned char* promela_specials [] = {
  a2_rightarrow(->),
  a2_and(&&),
  a2_or(||),
  a2_neq(!=),
  a2_equiv(==),
  a2_leq(<=),
  a2_geq(>=),
  /* ! cannot be translated as not, since it is used for "send" */
  UNULL
};
const unsigned char* promela_keywords [] = {
  a2_keyword(BOLD, active, assert, atomic, bit, bool, break, byte, chan,
d_step, progress, do, else, empty, enabled, fi, full, goto, hidden,
if, init, int, len, accept, mtype, nempty, never, nfull, od, of,
pc_value, printf, proctype, run, short, skip, timeout, typedef,
unless, xr, xs, priority)
  /* Preprocessor */
  a2_keyword(BOLD, #define, #if, #endif)
   UNULL
};
const char * promela_abbreviations[]= {
  "pml", "\0"
};
const unsigned char  promela_description[] =
  "There is no way for a2ps to highlight send and receive primitives.";
#define promela_style { "promela", 					\
  promela_abbreviations, promela_description, 				\
  CASE_INSENSITIVE, c_characters, c_characters,	promela_keywords,	\
  EMPTY, promela_specials, c_sequences, sh_verbatims, EMPTY }

/*
 *		SDL 88
 */
const unsigned char* sdl_sequences [] = {
  a2_sequence(/*, ITALIC, ITALIC,	*/, ITALIC),
  a2_sequence(\", COURIER, TIMES,	\", COURIER),
  a2_sequence(\', COURIER, TIMES, 	\', COURIER),
  a2_sequence(`(.', COURIER, COURIER,`.)', COURIER),
  a2_sequence(<<, COURIER, COURIER,>>, COURIER),
  UNULL
};
const unsigned char sdl_characters [] = {
  '_', '_',
  '\0'
};
const unsigned char* sdl_specials [] = {
  a2_rightarrow(->),
  a2_imply(=>),
  a2_neq(/=),
  a2_equiv(==),
  a2_leq(<=),
  a2_geq(>=),
  a2_not(!),
  UNULL
};
const unsigned char* sdl_keywords [] = {
  a2_keyword(BOLD, active, adding, all, alternative, any, as, atleast,
axioms, block, call, channel, comment, connect, connection, constant,
constants, create, dcl, decision, default, else, endalternative,
endblock, endchannel, endconnection, enddecision, endgenerator,
endnewtype, endoperator, endpackage, endprocedure, endprocess,
endrefinement, endselect, endservice, endstate, endsubstructure,
endsyntype, endsystem, enum, env, error, export, exported, external,
fi, finalized, for, fpar, from, gate, generator, if, import, imported,
in, inherits, input, interface, join, literal, literals, map,
nameclass, newtype, nextstate, nodelay, noequality, none, now,
offspring, operator, operators, ordering, out, output, package,
parent, priority, procedure, process, provided, redefined, referenced,
refinement, remote, reset, return, returns, revealed, reverse, save,
select, self, sender, service, set, signal, signallist, signalroute,
signalset, spelling, start, state, stop, struct, substructure,
synonym, syntype, system, task, then, this, timer, to, type, use,
variant, varstruct, via, view, viewed, virtual, with, or, xor, and,
mod, rem, not, start, end, macrodefinition, system, priority, =>, /=,
>, >=, <, <=, +, -, //, ==>, ==, ->, :=, *, :, /, =, !)
   UNULL
};
const char * sdl_abbreviations[]= {
  "pr", "sdl", "\0"
};
const unsigned char  sdl_description[] = "";
#define sdl_style { "sdl-88",						\
  sdl_abbreviations, sdl_description, 					\
  CASE_INSENSITIVE, sdl_characters, sdl_characters, sdl_keywords,	\
  EMPTY, sdl_specials, sdl_sequences, sh_verbatims, EMPTY }

/************************************************************************/
/*			         Fortran      			   	*/
/************************************************************************/
/*
 *		Fortran (Fortran 90 - with some keywords of HPF)
 *
 * For comments, we support only the free format (! anywhere on the line,
 * and not the old fixed format ^[cC*]).
 *
 */
/* Denis GIROU (CNRS/IDRIS - France) <Denis.Girou@idris.fr> - 10 Oct. 1996 */

const unsigned char* fortran_sequences [] = {
  /* comments */
  a2_sequence(!, italic, italic, \n, courier),
  /* char and strings litteral */
  a2_sequence(\', courier, times, \', courier),
  a2_sequence(\", courier, times, \", courier),
  /* Sections in the source file */
  a2_sequence(program , emph, emph, \n, emph),
  a2_sequence(end program , emph, emph, \n, emph),
  a2_sequence(subroutine , emph, emph, \n, emph),
  a2_sequence(end subroutine , emph, emph, \n, emph),
  a2_sequence(function , emph, emph, \n, emph),
  a2_sequence(end function , emph, emph, \n, emph),
  a2_sequence(module , emph, emph, \n, emph),
  a2_sequence(end module , emph, emph, \n, emph),
  a2_sequence(interface , emph, emph, \n, emph),
  a2_sequence(end interface , emph, emph, \n, emph),
  UNULL
};
const unsigned char fortran_characters [] = {
  '_', '_',
  '\0'
};
const unsigned char* fortran_specials []  = {
  /* boolean operations */
  a2_not(.not.),
  a2_and(.or.),
  a2_or(.and.),
  /* comparatives */
  a2_geq(.ge.),
  a2_symbol(.gt., >),
  a2_equiv(.eq.),
  a2_neq(.ne.),
  a2_symbol(.lt., <),
  a2_leq(.le.),
	/* ad: je ne vois pas ce que c'est */
  (ustring) ".eqv.", (ustring) ".eqv.", FONT_BOLD,	
  (ustring) ".neqv.", (ustring) ".neqv.", FONT_BOLD,

  /* Are those really usefull
  "(/", "(/", FONT_SYMBOL,		
  "/)", "/)", FONT_SYMBOL,
  "=", "=", FONT_SYMBOL,
  a2_imply(=>),
  "::", "::", FONT_SYMBOL,
  ";", ";", FONT_SYMBOL,	*/
  UNULL
};
const unsigned char* fortran_keywords [] = {
  /* Fortran keywords */
  a2_keyword(bold, access, align, allocate, assign, backspace, blanck,
block, call, case, close, common, continue, cycle, cyclic, data,
deallocate, default, define, distribute, doall, do, dynamic, elseif,
elsewhere, else, endfile, enddo, endif, end, entry, equivalence, err,
exit, .false., file, find, forall, form, format, goto, hpf, if,
include, independent, inherit, inquire, iostat, mask, namelist, new,
no, nullify, onto, pause, private, processors, pure, read, realign,
recl, recursive, redistribute, result, return, rewind, select, status,
stop, template, then, .true., unit, where, with, write)

  /* Fortran intrinsic functions */
  a2_keyword(bold, abs, achar, acos, ajustl, ajustr, aimag, aint, all,
allocated, anint, any, asin, associated, atan, atan2, bit_size, btest,
ceiling, char, cmplx, conjg, cos, cosh, count, cshift, date_and_time,
dble, digits, dim, dot_product, dprod, eoshift, epsilon, exp,
exponent, floor, fraction, huge, iachar, iand, ibclr, ibits, ibset,
ichar, ieor, index, int, ior, ishft, ishftc, lbound, len, len_trim,
lge, lgt, lle, llt, log, log10, matmul, max, maxexponent, maxloc,
maxval, merge, min, minexponent, minloc, minval, mod, modulo, mvbits,
nearest, nint, not, pack, precision, present, product, radix,
random_number, random_seed, range, repeat, reshape, rrspacing, scale,
scan, set_exponent, shape, sign, sin, sinh, size, spacing, spread,
sqrt, sum, system_clock, tan, tanh, tiny, transfer, transpose, trim,
ubound, unpack, verify)

  /* Fortran keywords for declarations */
  a2_keyword(italic, character, complex, double, integer, logical, real,
allocatable, assignment, dimension, entry, external, implicit, in,
inout, intent, intrinsic, kind, none, only, operator, optional, out,
parameter, pointer, precision, private, public, recursive, result,
save, selected_int_kind, selected_real_kind, target, type, use)
  UNULL
};
const char * fortran_abbreviations[]= {
  "f90", "f9", "f", "\0"
};
const unsigned char  fortran_description[] =
"For comments, we support only the free format (! anywhere on the line,"
"* and not the old fixed format ^[cC*]).\n"
"This style is to check.\n"
"Please report changes needed to Denis.Girou@idris.fr";
#define fortran_style { "fortran",					\
  fortran_abbreviations, fortran_description, 				\
  CASE_INSENSITIVE, fortran_characters, fortran_characters, fortran_keywords, \
  EMPTY, fortran_specials, fortran_sequences, sh_verbatims, EMPTY }

/************************************************************************/
/*			Assembly languages			   	*/
/************************************************************************/
/*
 *		Motorola 68000
 */
const unsigned char m68000_characters [] = {
  '.', '.',
  '\0'
};
const unsigned char* m68000_keywords [] = {
  /* Preprocessor */
  a2_preprocessor_keywords

  a2_keyword(BOLD, .data, .globl, .long, .skip, .text)

  a2_keyword(BOLD, addw, beq, bgt, ble, bne, bra, bset, btst, clrl,
cmpl, jmp, jsr, movel, moveb, moveml, movew, movw, rte, rts, subw,
subql, tstl)
   UNULL
};
const unsigned char* m68000_sequences [] = {
  /* comments */
  a2_sequence(|#, courier, emph,  \n, courier),
  a2_sequence(|*, courier, emph,  \n, courier),
  a2_sequence(|, courier, italic, \n, courier),
  UNULL
};
const char * m68000_abbreviations[]= {
  "68000", "S", "s", "\0"
};
const unsigned char m68000_description[] =
  "This style is devoted to the assembly language of the Motorola 68000. "
  "It is still experimental. Send comments to demaille@inf.enst.fr";
#define m68000_style { "68000", 					\
  m68000_abbreviations, m68000_description, 				\
  CASE_INSENSITIVE, m68000_characters, m68000_characters, m68000_keywords,\
  EMPTY, EMPTY, m68000_sequences, sh_verbatims, EMPTY }

/************************************************************************/
/*									*/
/* 		Definition of the struct for the styles			*/
/*									*/
/************************************************************************/
/*
 * Note: HTML can be included, but works badly
 */
/* #ifdef HTML_STYLE
 *   html
 * #endif
 */

a2_styles(ada, c, cpp, caml, claire, coq, clisp, eiffel, fortran,
java, lace, m68000, mail, modula3, o2c, oberon, pascal, perl,
postscript, prescript, promela, python, sather, scheme, sdl, sh, tcl,
tk, zsh)

int NBR_LANGUAGES = sizeof(languages) / sizeof(languages[0]);
